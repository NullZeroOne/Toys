<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Scoundrel ‚Äî Single-Page Web App</title>
<style>
  :root{
    --bg:#0f1220;
    --panel:#171a2b;
    --ink:#e9ecff;
    --muted:#b7bfef;
    --accent:#8fd3ff;
    --danger:#ff7a7a;
    --ok:#79e58a;
    --card:#222642;
    --btn:#2a2f51;
    --btn-hover:#36407a;
    --disabled:#404565;
    --reco:#ffd76a;
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Helvetica, Arial, sans-serif;
    background:linear-gradient(180deg, #0a0d1a, var(--bg));
    color:var(--ink);
    min-height:100vh;
    display:flex;
    align-items:flex-start;
    justify-content:center;
    padding:24px;
  }
  .app{width:min(100%,980px);background:var(--panel);border:1px solid #2a2f51;
    border-radius:16px;padding:18px;box-shadow:0 20px 50px rgba(0,0,0,.35);}
  header{display:flex;flex-wrap:wrap;align-items:center;gap:12px 16px;justify-content:space-between;margin-bottom:8px;}
  .title{font-weight:700;}
  .hud{display:flex;gap:18px;flex-wrap:wrap;align-items:center;}
  .stat{background:var(--card);padding:8px 12px;border-radius:10px;border:1px solid #2c3155;font-weight:600;}
  .row{display:flex;gap:12px;align-items:center;justify-content:space-between;margin:8px 0 14px;flex-wrap:wrap}
  .row .left{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  button{cursor:pointer;background:var(--btn);color:var(--ink);border:1px solid #3a3f6d;border-radius:10px;padding:10px 14px;font-weight:600;}
  button:hover{background:var(--btn-hover);} button:disabled{opacity:.55;cursor:not-allowed;background:var(--disabled);}
  .room{display:grid;grid-template-columns:repeat(4,1fr);gap:14px;}
  .card{background:var(--card);border:1px solid #2e3361;border-radius:14px;padding:12px;display:flex;flex-direction:column;gap:8px;min-height:170px;}
  .face{display:flex;align-items:center;justify-content:space-between;gap:10px;background:#1c2142;border:1px solid #353c7a;border-radius:10px;padding:8px 10px;font-weight:700;}
  .suit{font-size:20px;} .red{color:#ff9aba;} .blk{color:#9ec7ff;}
  .kind{font-size:12px;color:var(--muted);}
  .actions{display:flex;flex-direction:column;gap:8px;margin-top:auto;}
  .log{margin-top:14px;background:var(--card);border:1px solid #2c3155;border-radius:12px;padding:10px 12px;max-height:220px;overflow:auto;font-size:14px;}
  .log p{margin:6px 0;color:#cbd2ff;} .ok{color:var(--ok);} .bad{color:var(--danger);}
  .footer{display:flex;gap:10px;justify-content:flex-end;margin-top:10px;}
  .pill{display:inline-flex;align-items:center;gap:8px;background:#1b2040;padding:8px 10px;border-radius:999px;border:1px solid #313a74;}
  .weaponStack{display:flex;gap:8px;flex-wrap:wrap;align-items:center;}
  .stackCard{background:#1b2040;border:1px solid #313a74;border-radius:8px;padding:6px 8px;font-size:13px;}
  .overlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(5,7,15,.7);}
  .modal{background:var(--panel);padding:20px;border-radius:14px;width:min(92vw,520px);border:1px solid #2a2f51;}
  .modal h2{margin:0 0 8px 0;} .modal p{color:var(--muted);} .modal .actions{flex-direction:row;margin-top:12px;gap:10px;}
  /* Recommendation highlight */
  .reco{
    box-shadow:0 0 0 3px var(--reco) inset, 0 0 0 1px #000;
    animation: pulse 1s ease-in-out infinite alternate;
  }
  @keyframes pulse{from{filter:brightness(1)} to{filter:brightness(1.2)}}
</style>
</head>
<body>
<div class="app">
  <header>
    <div class="title">üó°Ô∏è Scoundrel</div>
    <div class="hud">
      <div class="stat">HP: <span id="hp">20</span></div>
      <div class="stat">Deck: <span id="deckCount">0</span></div>
      <div class="stat">Discard: <span id="discardCount">0</span></div>
      <div class="stat">Moves: <span id="moves">0</span>/3</div>
    </div>
  </header>
  <div class="row">
    <div class="left">
      <button id="runBtn">Run</button>
      <button id="recoBtn" title="Suggest the next move">Recommendation</button>
    </div>
    <div class="pill"><strong>Weapon:</strong>&nbsp;<span id="weaponLabel">None</span>
      <div class="weaponStack" id="weaponStack"></div>
    </div>
  </div>
  <section class="room" id="room"></section>
  <section class="log" id="log"></section>
  <div class="footer"><button id="restartBtn" style="display:none">Play Again</button></div>
</div>
<div class="overlay" id="overlay">
  <div class="modal">
    <h2 id="modalTitle"></h2><p id="modalMsg"></p>
    <div class="actions">
      <button id="modalKeepGoing">Keep Going!</button>
      <button id="modalRestart">Play Again</button>
    </div>
  </div>
</div>

<script>
(() => {
  const SUITS=["‚ô•","‚ô¶","‚ô£","‚ô†"],RANKS=["A","2","3","4","5","6","7","8","9","10","J","Q","K"];
  const val=r=>r==="A"?1:r==="J"?11:r==="Q"?12:r==="K"?13:parseInt(r,10);
  const isRed=s=>s==="‚ô•"||s==="‚ô¶";
  const kind=c=>c.suit==="‚ô¶"?"weapon":c.suit==="‚ô•"?"potion":"monster";
  const fmt=c=>c.rank+c.suit;
  const clampHP = hp => Math.max(0, Math.min(20, hp)); // cap at 20
  function shuffle(a){for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];}return a;}

  // DOM helper
  function $(id){return document.getElementById(id)}

  // Globals for quick access
  const hpEl=$("hp"), deckCount=$("deckCount"), discardCount=$("discardCount"), movesEl=$("moves");
  const roomEl=$("room"), runBtn=$("runBtn"), recoBtn=$("recoBtn"), restartBtn=$("restartBtn");
  const overlay=$("overlay"), modalTitle=$("modalTitle"), modalMsg=$("modalMsg"), modalRestart=$("modalRestart"), modalKeepGoing=$("modalKeepGoing");
  const weaponLabel=$("weaponLabel"), weaponStackEl=$("weaponStack");

  let state;

  function newGame(){
    const deck=[];
    for(const s of SUITS){
      for(const r of RANKS){
        if(isRed(s) && ["A","J","Q","K"].includes(r)) continue; // remove red aces & red face cards
        deck.push({rank:r,suit:s,value:val(r),type:null});
      }
    }
    deck.forEach(c=>c.type=kind(c));
    shuffle(deck);

    state={
      hp:20,
      deck,
      discard:[],
      room:[],
      moves:0,
      potionDrunk:false,
      weapon:[],   // stack [weapon, defeated M1, M2, ...]
      ranLast:false,
      over:false,
      reco:null    // {type, idx} or {run:true}
    };

    drawToRoom(4);
    render();
    log("New game started. First room drawn.");
  }

  function drawToRoom(n){
    while(state.deck.length && state.room.length<4 && n>0){
      state.room.push(state.deck.shift());
      n--;
    }
    updHUD();
  }

  function log(m,cls=""){
    const p=document.createElement("p");
    if(cls) p.className=cls;
    p.textContent=m;
    const el=$("log");
    el.appendChild(p);
    el.scrollTop=el.scrollHeight;
  }

  function updHUD(){
    hpEl.textContent=state.hp;
    deckCount.textContent=state.deck.length;
    discardCount.textContent=state.discard.length;
    movesEl.textContent=state.moves;
  }

  function canUseW(mon){
    if(!state.weapon.length) return false;
    if(state.weapon.length===1) return true; // first use unrestricted
    const last=state.weapon[state.weapon.length-1];
    return mon.value < last.value;
  }
  function baseVal(){ return state.weapon.length?state.weapon[0].value:0; }

  // Potion heal computation with HP cap and per-room ‚Äúonly first heals‚Äù rule
  function potionHealAmount(card){
    if(state.potionDrunk) return 0;
    const roomCap = 20 - state.hp;
    return Math.max(0, Math.min(card.value, roomCap));
  }

  function attackUnarmed(idx){
    if(state.over) return;
    clearReco();
    const c=state.room[idx];
    if(!c || c.type!=="monster") return;
    const dmg = c.value;
    state.hp = clampHP(state.hp - dmg);
    state.discard.push(c);
    state.room.splice(idx,1);
    state.moves++;
    log(`Unarmed vs ${fmt(c)} ‚Äî took ${dmg}. HP ${state.hp}`, dmg?"bad":"ok");
    after();
  }

  function attackWithWeapon(idx){
    if(state.over) return;
    clearReco();
    const c=state.room[idx];
    if(!c || c.type!=="monster") return;
    if(!canUseW(c)) return;
    const dmg = Math.max(c.value - baseVal(), 0);
    state.hp = clampHP(state.hp - dmg);
    // defeated: stack on weapon
    state.weapon.push(c);
    state.room.splice(idx,1);
    state.moves++;
    log(`Weapon ${fmt(state.weapon[0])} vs ${fmt(c)} ‚Äî took ${dmg}. HP ${state.hp}`, dmg?"bad":"ok");
    after();
  }

  function equip(idx){
    if(state.over) return;
    clearReco();
    const c=state.room[idx];
    if(!c || c.type!=="weapon") return;
    if(state.weapon.length) state.discard.push(...state.weapon);
    state.weapon=[c];
    state.room.splice(idx,1);
    state.moves++;
    log(`Equipped ${fmt(c)}.`, "ok");
    after();
  }

  function drinkPotion(idx){
    if(state.over) return;
    clearReco();
    const c=state.room[idx];
    if(!c || c.type!=="potion") return;
    const heal = potionHealAmount(c);
    if(heal>0){
      state.hp = clampHP(state.hp + heal);
      state.potionDrunk = true;
      log(`Drank ${fmt(c)} ‚Äî +${heal} HP. Now ${state.hp}.`,"ok");
    } else {
      const reason = state.potionDrunk ? "already drank a potion this room" : "HP already at cap";
      log(`Drank ${fmt(c)} ‚Äî +0 (${reason}).`);
      if(!state.potionDrunk) state.potionDrunk = true;
    }
    state.discard.push(c);
    state.room.splice(idx,1);
    state.moves++;
    after();
  }

  function run(){
    if(state.over) return;
    clearReco();
    if(state.moves>=3){ next(); return; }
    if(state.room.length!==4 || state.ranLast) return;
    state.deck.push(...state.room);
    state.room=[];
    drawToRoom(4);
    state.potionDrunk=false;
    state.moves=0;
    state.ranLast=true;
    log("Ran away; drew new room.");
    render();
  }

  function next(){
    if(state.over) return;
    clearReco();
    if(state.moves<3) return;
    if(!state.deck.length){
      log("No cards left to draw.");
      render();
      return;
    }
    state.moves=0;
    state.potionDrunk=false;
    state.ranLast=false;
    drawToRoom(3);
    log("Next turn: refilled room.");
    render();
  }

  function after(){
    updHUD();
    if(state.hp<=0){
      over("Defeated","You‚Äôve been reduced to 0 HP.");
      return;
    }
    if(!state.deck.length && !state.room.length){
      over("Victory!","You cleared the deck.");
      return;
    }
    render();
  }

  function over(t,m){
    state.over=true;
    modalTitle.textContent=t;
    modalMsg.textContent=m;
    overlay.style.display="flex";
    restartBtn.style.display="inline-block";
  }

  // --- Recommendation system ---
  function clearReco(){ state.reco=null; }

  function cloneState(src){
    return {
      hp: src.hp,
      deck: src.deck.slice(), // deck order unused during 3-move sim
      discard: src.discard.slice(),
      room: src.room.map(c=>({...c})),
      moves: src.moves,
      potionDrunk: src.potionDrunk,
      weapon: src.weapon.map(c=>({...c})),
      ranLast: src.ranLast,
      over: src.over
    };
  }

  function canUseW_in(sim, mon){
    if(!sim.weapon.length) return false;
    if(sim.weapon.length===1) return true;
    const last = sim.weapon[sim.weapon.length-1];
    return mon.value < last.value;
  }
  function baseVal_in(sim){ return sim.weapon.length ? sim.weapon[0].value : 0; }
  function potionHeal_in(sim, card){
    if(sim.potionDrunk) return 0;
    const roomCap = 20 - sim.hp;
    return Math.max(0, Math.min(card.value, roomCap));
  }

  function applyAction(sim, action){
    // action = {type: 'unarmed'|'weapon'|'equip'|'potion', idx:number}
    if(sim.over) return sim;
    const c = sim.room[action.idx];
    if(!c) return sim;
    if(action.type==='unarmed' && c.type==='monster'){
      sim.hp = clampHP(sim.hp - c.value);
      sim.discard.push(c);
      sim.room.splice(action.idx,1);
      sim.moves++;
    } else if(action.type==='weapon' && c.type==='monster'){
      if(!canUseW_in(sim, c)) return null; // illegal
      const dmg = Math.max(c.value - baseVal_in(sim), 0);
      sim.hp = clampHP(sim.hp - dmg);
      sim.weapon.push(c);
      sim.room.splice(action.idx,1);
      sim.moves++;
    } else if(action.type==='equip' && c.type==='weapon'){
      if(sim.weapon.length) sim.discard.push(...sim.weapon);
      sim.weapon=[c];
      sim.room.splice(action.idx,1);
      sim.moves++;
    } else if(action.type==='potion' && c.type==='potion'){
      const heal = potionHeal_in(sim, c);
      sim.hp = clampHP(sim.hp + heal);
      if(heal>0 || !sim.potionDrunk){ sim.potionDrunk = true; }
      sim.discard.push(c);
      sim.room.splice(action.idx,1);
      sim.moves++;
    } else {
      return null; // invalid
    }
    return sim;
  }

  function enumerateActions(sim){
    const acts=[];
    if(sim.moves>=3) return acts;
    // actions for each card in room
    sim.room.forEach((c, idx)=>{
      if(c.type==='monster'){
        acts.push({type:'unarmed', idx});
        if(canUseW_in(sim, c)) acts.push({type:'weapon', idx});
      } else if(c.type==='weapon'){
        acts.push({type:'equip', idx});
      } else if(c.type==='potion'){
        acts.push({type:'potion', idx}); // Drink (+heal or +0) is always allowed
      }
    });
    return acts;
  }

  // Try all legal sequences of exactly 3 actions from current room; pick best surviving (max HP)
  function computeRecommendation(){
    const start = cloneState(state);
    start.reco=null;

    // If we already took moves in this room, we still recommend from *now* up to 3 total
    function dfs(sim, seq){
      if(sim.moves>=3 || sim.hp<=0){
        return [{seq, hp: sim.hp, ok: sim.hp>0}];
      }
      const results=[];
      const acts = enumerateActions(sim);
      for(const a of acts){
        const sim2 = cloneState(sim);
        const applied = applyAction(sim2, {...a});
        if(!applied) continue;
        results.push(...dfs(applied, seq.concat(a)));
      }
      // If no actions (empty room or only 1 card & deck empty), still return terminal
      if(results.length===0){
        results.push({seq, hp: sim.hp, ok: sim.hp>0});
      }
      return results;
    }

    const all = dfs(start, []);
    // Filter to sequences that end with moves==3 (or fewer if room exhausted) and hp>0
    const survivable = all.filter(r => r.ok);
    if(survivable.length){
      // Choose max hp; tie-break by fewest total damage then by preferring using weapon when possible (not necessary)
      survivable.sort((a,b)=> b.hp - a.hp);
      const best = survivable[0];
      // Recommend first action of the best sequence, if any; otherwise, if already at 3 moves, recommend Next turn
      const next = best.seq[0];
      if(next){
        return {type: next.type, idx: next.idx};
      } else {
        // No action needed (strange corner); recommend Next turn if available
        return {nextTurn:true};
      }
    } else {
      // No survivable sequence; if can run, suggest run
      const canRun = (state.moves<3 && state.room.length===4 && !state.ranLast);
      if(canRun) return {run:true};
      return {dire:true};
    }
  }

  function recommend(){
    clearReco();
    const r = computeRecommendation();
    if(r.run){
      state.reco = {run:true};
      log("Recommendation: Run.", "bad");
    } else if(r.nextTurn){
      state.reco = {nextTurn:true};
      log("Recommendation: Next turn.", "ok");
    } else if(r.dire){
      log("Things look dire.");
      state.reco = null;
    } else if(r && typeof r.idx==="number"){
      state.reco = {type:r.type, idx:r.idx};
      const c = state.room[r.idx];
      const actionName = r.type==='unarmed' ? "Attack unarmed" :
                         r.type==='weapon'  ? "Attack with weapon" :
                         r.type==='equip'   ? "Equip weapon" :
                         r.type==='potion'  ? "Drink potion" : "Move";
      log(`Recommendation: ${actionName} on ${fmt(c)}.`, "ok");
    }
    render(); // to apply highlight
  }

  // --- Rendering ---
  function render(){
    updHUD();
    roomEl.innerHTML="";

    // Run/Next button state
    runBtn.textContent = state.moves>=3 ? "Next turn" : "Run";
    runBtn.disabled = (state.moves<3)
      ? !(state.room.length===4 && !state.ranLast)
      : (!state.deck.length);

    // Apply recommendation highlight to Run / Next turn if applicable
    runBtn.classList.toggle("reco", !!(state.reco && (state.reco.run || state.reco.nextTurn)));

    const hideSoleCarry = state.moves>=3 && state.deck.length>0 && state.room.length===1;

    state.room.forEach((c,i)=>{
      const d=document.createElement("div");
      d.className="card";
      d.innerHTML = `
        <div class="face">
          <span>${c.rank}</span>
          <span class="suit ${isRed(c.suit)?"red":"blk"}">${c.suit}</span>
        </div>
        <div class="kind">${c.type.toUpperCase()}</div>
      `;
      const actions=document.createElement("div");
      actions.className="actions";

      // Helper to attach and mark reco
      function addAction(btn, type){
        btn.dataset.idx = i;
        btn.dataset.action = type;
        if(state.reco && state.reco.idx==i && state.reco.type===type){
          btn.classList.add("reco");
        }
        actions.appendChild(btn);
      }

      if(!hideSoleCarry){
        if(c.type==="monster"){
          const un=document.createElement("button");
          un.textContent=`Attack (unarmed) ‚Äî take ${c.value}`;
          un.onclick=()=>attackUnarmed(i);
          addAction(un, 'unarmed');

          if(canUseW(c)){
            const w=document.createElement("button");
            const dmg = Math.max(c.value - baseVal(), 0);
            w.textContent=`Attack (weapon ${state.weapon.length?fmt(state.weapon[0]):"‚Äî"}) ‚Äî take ${dmg}`;
            w.onclick=()=>attackWithWeapon(i);
            addAction(w, 'weapon');
          }
        } else if(c.type==="weapon"){
          const b=document.createElement("button");
          b.textContent=`Equip weapon (value ${c.value})`;
          b.onclick=()=>equip(i);
          addAction(b, 'equip');
        } else if(c.type==="potion"){
          const heal = potionHealAmount(c); // uses per-room restriction and HP cap
          const b=document.createElement("button");
          b.textContent=`Drink (+${heal})`;
          b.onclick=()=>drinkPotion(i);
          addAction(b, 'potion');
        }
      } else {
        const note=document.createElement("div");
        note.className="kind";
        note.textContent="Will carry over to next room.";
        actions.appendChild(note);
      }

      d.appendChild(actions);
      roomEl.appendChild(d);
    });

    // Weapon label & stack
    weaponStackEl.innerHTML="";
    if(!state.weapon.length){
      weaponLabel.textContent="None";
    } else {
      weaponLabel.textContent=`${fmt(state.weapon[0])} (value ${state.weapon[0].value})`;
      for(let j=1;j<state.weapon.length;j++){
        const sc=document.createElement("span");
        sc.className="stackCard";
        sc.textContent=fmt(state.weapon[j]);
        weaponStackEl.appendChild(sc);
      }
    }
  }

  // UI hooks
  runBtn.onclick = ()=>{ if(state.moves>=3) next(); else run(); };
  recoBtn.onclick = recommend;
  restartBtn.onclick = ()=>{ overlay.style.display="none"; newGame(); };
  modalRestart.onclick = ()=>{ overlay.style.display="none"; newGame(); };
  modalKeepGoing.onclick = ()=>{
    // Restore to full and continue from where you fell
    overlay.style.display="none";
    state.over=false;
    state.hp = 20;
    updHUD();
    log("Keep Going! Restored to 20 HP.", "ok");
    render();
  };

  // bootstrap
  newGame();
})();
</script>
</body>
</html>
